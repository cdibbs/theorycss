<html>
	<head>
		<title>Theory Tests</title>
		<script type='text/javascript' src='http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js'></script>
		<script type='text/javascript' src='theory.js'></script>
		<script type='text/javascript' src='test.js'></script>
		<script type='text/javascript' src='compiler.js'></script>
		<script type='text/javascript'>
			$(document).ready(function() {
				theory.yy = theoryCompiler;
				theory.lexer.options.backtrack_lexer = true;
				var result = theory.parse($('#best').text());
				console.log(result);
			});
		</script>
		tree frags => [[div]] [[span]] |_ x3
		frag functions => ((node)) ((child)) ((...))
		function expressions => fn name(bob) -> expression
		data definitions
		theories
		
		Needed:
		- way to auto-generate colorblind version of stylesheets
		- mimick:
			- arbitrary descendant
			- direct descendant
		
		demos:
		- square box in parent rect
		- fractal
		- html gen?

			/*
			data Number a = long a | int a | float a | double a;
			data RGBa c = (int r, int g, int b, float a);
			data HSLa c = (float h, float s, float l, float a);
			data Color c = RGBa c | HSLa c;
			data Tree a =  Leaf a | Branch [Tree a];
			data ImgCtx ctx = (string source, string alt, image img);
			every ImgCtx can
				fn blaaaah() -> 0
				
			portrait = new ImgCtx(url, text)
			this portrait can
				fn blah() -> 0
				
			data Image img = { [Attr], [ImgCtx] };  
			*/
			
			/*Image OurOffice {
				src = '/img/stock-photo.jpg',
				alt = 'Our office',
				
				ImgCtx Bannerized = fn(Color tint = Tertiary.Veridian)
					-> filter(tint, trim(scale(self, ...))),
				
				ImgCtx Taggable = fn()
					-> doStuffToEnhanceIt()
			}*/
		<script type='text/x-theory' id='best'>
namespace Website
	theory Main
		[[html]]
			[[body]]
				[[div.navbar]] ::
					is { 'z-index' : 1030 };
					@tablet is fixedbar('top', 32px);
					@mobile is gone
				[[div.main]]
					[[div.leftmenu :: LeftMenu]]
					[[div.content :: Article]]
				[[div.footer]]
				
		ff curveddeck() -> 
			((any))
				((...))

		</script>
		<script type='text/x-theory' id='thoughts'>
			/* my very first theory */
			namespace Color {
				
				namespace RYB {
					namespace Primary {
						[-- Colors --]
						Red = 3;
						Red = Color(255, 0, 0, 1);
						Yellow = RGBa(255, 255, 0, 1);
						Blue = RGBa(0, 0, 255, 1);
					};
					
					namespace Secondary {
						[-- Colors --]
						Orange = (Red + Yellow) / 2;
						Purple = (Red + Blue) / 2;
						Green = (Yellow + Blue) / 2;
					};
					
					namespace Tertiary {
						[-- Colors --]
						Vermilion = (Red + Orange) / 2;
						Amber = (Yellow + Orange) / 2;
						Chartreuse = (Yellow + Green) / 2;
						Viridian = (Blue + Green) / 2;
						Violet = (Blue + Purple) / 2;
						Magenta = (Red + Purple) / 2;
					};
				};
								
				fn rgba(int r, int g, int b, int a = 1) -> Tuple(r, g, b, a);
				
				fn ryba(int r, int y, int b, int a = 1) -> Tuple(r, (y+b)/2, b, a);
				
				fn hsla(int h, int s, int l, int a = 1) -> Tuple();
				
				/**
	 			* Darkens a color by a decimal. p = 0.05 means darken L by 5%, in HSL.
	 			*/ 
				fn Darken(Color c, Number p) -> c * (1 - p);

				/**
	 			* Lightens a color by a decimal. p = 0.05 means lighten L by 5%, in HSL.
	 			*/
				fn Lighten(Color c, Number p) -> c * (1 + p);

				/**
				 * Sets the lightness of a Color (range 0.0 to 1.0) in HSL
				 */
				fn SetLightness(Color c, Number p) -> 0; /*(c.toHSLa() && (-1,-1,0,-1)) || (0,0,-p,0);*/
			
				/**
				 * 
				 */
				fn Complement(Color c) -> Rotate(c, 180);
			
				fn Rotate(Color c, Number degrees) -> 0;
			
				/**
				 * Given a color, find the two colors adjacent to its complement at the given
				 * division level of the color wheel (1 = primary colors, 2 = secondary, etc),
				 * where the level indicates 3*2^(level-1) divisions of the wheel. The complement 
				 * pair on the tertiary wheel (level = 3) would each be +/- 15 degrees from
				 * the complement.  
				 */
				fn ComplementPair(Color c, Number level)
					-> [ Rotate(c, 180-360/3*2**(level-1)),
						 Rotate(c, 180+360/3*2**(level-1)) ];
						 
			}
			
			namespace css {
				fixed = \{ display:fixed }
				absolute = \{ display:absolute }
				relative = \{ display:relative }
				gone = \{ display:none }
				
				boxSides = \{ top:auto, right:auto, bottom:auto, left:auto }
				
				with boxSides:
					fn prev(which) ->
						this[p]
						where p = this.keyIndex(which)-1
						
					fn next(which) -> 
						this[n]
						where n = this.keyIndex(which)+1
					
					fn adjacent(which) ->
						this.prev(which) union this.next(which)
						
					fn opposite(which) ->
						this.next(which).next(which)
			}
			
			theory Main {
				[[html]]
					[[body]]
						[[div.navbar]]
							is fixedbar('top', thickness = 32px), { 'z-index' : 1030 }
							@tablet is fixedbar('top', 32px)
							@mobile is gone
							
						[[div.main]]
							@? \media -> minutia[media]
							
							[[div.content :: Article]] 
								
							[[div.demo]]
								// three decks, 7 cards each
								[[div.deck]] x 3 : curveddeck()
									[[div]] 
										|_ x 7
									
						[[div.footer]]
							is footer
						
				
				[-- FragFuncs --]
				ff fixedbar(side, thickness) = 
					((block))
						-> style (fixed + (boxSides - boxSides.opposite(side)))
						<- style if t?! then { axis : t } else nothing endif
							where axis = 'height' if side in ('top', 'bottom') else 'width' endif
							yield thickness = t
						
						((...)) // e.g., bootstrap-y .container, .row, .row-fluid, etc  
							((a)) 
								((img))
									<- yield t = if (thickness!) then
												thickness
											else 
												(if align in ('top', 'bottom') then img.height else img.width endif) 
												?? thickness
											endif
							((\login))
						
					
				ff curveddeck() = 
					((any))
						-> yield x = 0, y = 0						
						((...))
							-> apply { position:relative, top:y, left:x, height:100% }
								where x = x * 2, y = y * 2
			
				[-- Colors :: Color --]
					dominant = rgba(255,255,0,1)
					(decor1, decor2) = ComplementPair(dominant, 3)
					scrunched @=
						desktop -> decor1
						tablet -> decor2
						mobile -> rgba(255,0,0,1)
					OffWhite = #fafafa
					
				[-- Media --]
					desktop = "screen and (width >= 1200px)"
					tablet = "screen and (width >= 800px)"
					mobile = "screen and (width >= 400px)"
					
				[-- Assertions --]
					IsTrue(Contrast(Colors.scrunched, Colors.dominant) > 0.5)
					AreEqual()				
			}
			
			/*test Main {
				[-- Colors :: Color --]
				IsTrue(Contrast(scrunched, dominant) > Contrasts.RGColorBlind_EasilyReadable);
			}*/
			
			theory Article {
				[-- Primitives --]
				numExplicitPages = 8
				
				[[div.content]]
					@desktop -> twocol()
					@mobile -> onecol()
					
					[[div.col1]]
						[[div.ads]]
					[[div.col2]]
					
					[[div.pager]]
						-> pager(numExplicitPages)
						
						[[table > tr]]
							[[td.leftmost]]
							[[td]] x numExplicitPages
							[[td.rightmost]]
							
				[-- FragFuncs --]
				ff pager(pages) =
					((block))
						((...))
							((td))
							((td)) x pages
								\i -> style \{ color : \rainbow(\i) }
							((td))
					 
			}
		</script>
	</head>
	<body>
	<div class='navbar-fixed-top'>
		<div class='navbar-inner'>
			<div class='container'>
				<div class='row'>
					<div class='span6'>
						<span class='hordz-logo'>Hordz.Org</span>
					</div>	
					<div class='span6'>
						<form method='post' class="navbar-form login-form" action='/accounts/logout'>
							<input type='hidden' name='csrfmiddlewaretoken' value='uMQTosgrQM5emlC1uWDmv6PjYnEG7iJZ' />
							<div>
								Welcome,
								<a href='/accounts/home' title='Go to your profile'>
									cdibbs</a>.
							</div>
							<button type="submit" class="logout-btn btn btn-primary">Logout</button>
							<a href='#' class='btn btn-info help-btn'>Help</a>
						</form>						
					</div>
				</div>
			</div>
		</div>
	</div>
		
	</body>
</html>
