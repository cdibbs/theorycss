<html>
	<head>
		<title>Theory Tests</title>
		<script type='text/javascript' src='http://ajax.googleapis.com/ajax/libs/jquery/1.8.3/jquery.min.js'></script>
		<script type='text/javascript' src='theory.js'></script>
		<script type='text/javascript' src='interpreter.js'></script>
		<script type='text/javascript'>
			$(document).ready(function() {
				theory.yy = theoryInterpreter;
				var result = theory.parse($('#kludge').text());
				console.log(result);
			});
		</script>
		<script type='text/x-theory' id='kludge'>
			data Number a = long a | int a | float a | double a;
			data RGBa c = (int r, int g, int b, float a);
			data HSLa c = (float h, float s, float l, float a);
			data Color c = RGBa c | HSLa c;
			
			
			/* my very first theory */
			theory Color {
				
				namespace Primary {
					Red = Color(255, 0, 0, 1),
					Yellow = RGBa(255, 255, 0, 1),
					Blue = RGBa(0, 0, 255, 1)
				};
				
				namespace Secondary {
					... Primary ...
					Orange = (Red + Yellow) / 2,
					Purple = (Red + Blue) / 2,
					Green = (Yellow + Blue) / 2
				};
				
				namespace Tertiary {
					... Secondary ...
					Vermilion = (Red + Orange) / 2,
					Amber = (Yellow + Orange) / 2,
					Chartreuse = (Yellow + Green) / 2,
					Viridian = (Blue + Green) / 2,
					Violet = (Blue + Purple) / 2,
					Magenta = (Red + Purple) / 2
				};
								
				fn Tuple rgba(int r, int g, int b, int a = 1) -> new Tuple(r, g, b, a);
				
				fn Tuple ryba(int r, int y, int b, int a = 1) -> new Tuple(r, (y+b)/2, b, a);
				
				fn Tuple hsla(int h, int s, int l, int a = 1) -> new Tuple();
				
				/**
	 			* Darkens a color by a decimal. p = 0.05 means darken L by 5%, in HSL.
	 			*/ 
				fn Color Darken(Color c, Number p) -> c * (1 - p);

				/**
	 			* Lightens a color by a decimal. p = 0.05 means lighten L by 5%, in HSL.
	 			*/
				fn Color Lighten(Color c, Number p) -> c * (1 + p);

				/**
				 * Sets the lightness of a Color (range 0.0 to 1.0) in HSL
				 */
				fn Color SetLightness(Color c, Number p) -> (c.toHSLa() and (-1,-1,0,-1)) or (0,0,-p,0);
			
				/**
				 * 
				 */
				fn Color Complement(Color c) -> Rotate(c, 180);
			
				fn Color Rotate(Color c, Number degrees) -> 0;
			
				/**
				 * Given a color, find the two colors adjacent to its complement at the given
				 * division level of the color wheel (1 = primary colors, 2 = secondary, etc),
				 * where the level indicates 3*2^(level-1) divisions of the wheel. The complement 
				 * pair on the tertiary wheel (level = 3) would each be +/- 15 degrees from
				 * the complement.  
				 */
				fn Color[] ComplementPair(Color c, Number level)
					-> [ Rotate(c, 180-360/3*2^(level-1)),
						 Rotate(c, 180+360/3*2^(level-1)) ];				
			}
			
			theory Main {
				[-- Colors --]
				dominant = rgba(255,255,0,1);
				(decor1, decor2) = ComplementPair(dominant, 3);
				scrunched @=
					desktop -> decor1
					tablet -> decor2
					mobile -> rgba(255,0,0,1);

				[-- Media --]
				desktop = "screen and (width >= 1200px)";
				tablet = "screen and (width >= 800px)";
				mobile = "screen and (width >= 400px)";
				
				fn Color Chris(Color variable) -> 0;
			}
			
			theory Another extends Bob {
				
			}
		</script>
	</head>
	<body>
		
		
	</body>
</html>